#!/usr/bin/env powershell
# Post-Tool-Use Hook - Learning System Integration (STDIN Version)
# Captures tool results via STDIN JSON instead of parameters

# Configuration - UPDATED TO USE UNIFIED DATABASE
$LearningSystemPath = "D:\learning-system"
$LogPath = "$LearningSystemPath\logs"
$DatabasePath = "D:\databases\database.db"  # UNIFIED DATABASE

# Ensure log directory exists
if (-not (Test-Path "$LogPath")) {
    New-Item -ItemType Directory -Path "$LogPath" -Force | Out-Null
}

$LogFile = Join-Path "$LogPath" "tool-usage-$(Get-Date -Format 'yyyy-MM-dd').log"
$Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"

try {
    # Read JSON data from STDIN
    $StdinData = @()
    while ($null -ne ($line = [Console]::In.ReadLine())) {
        $StdinData += $line
    }

    $JsonInput = $StdinData -join "`n"

    # Parse JSON to get tool information
    $ToolData = $JsonInput | ConvertFrom-Json -ErrorAction SilentlyContinue

    # Extract tool name and success status
    $ToolName = "Unknown"
    if ($ToolData.toolName) { $ToolName = $ToolData.toolName }
    elseif ($ToolData.tool_name) { $ToolName = $ToolData.tool_name }
    elseif ($ToolData.name) { $ToolName = $ToolData.name }
    elseif ($ToolData.tool) { $ToolName = $ToolData.tool }

    # Extract success status (try different possible field names)
    $SuccessBool = $true
    if ($null -ne $ToolData.success) { $SuccessBool = $ToolData.success }
    elseif ($null -ne $ToolData.succeeded) { $SuccessBool = $ToolData.succeeded }
    elseif ($null -ne $ToolData.error) { $SuccessBool = -not $ToolData.error }

    $Status = if ($SuccessBool) { "SUCCESS" } else { "FAILURE" }

    # Log tool result with actual data
    $LogEntry = "[$Timestamp] [POST-TOOL] Tool: $ToolName | Status: $Status | JSON: $($JsonInput.Substring(0, [Math]::Min(100, $JsonInput.Length)))"
    Add-Content -Path "$LogFile" -Value "$LogEntry" -ErrorAction SilentlyContinue

    # Sanitize inputs to prevent SQL injection
    $SafeToolName = "$ToolName" -replace "'", "''"
    $SafeTimestamp = "$Timestamp" -replace "'", "''"
    $MistakeType = if (-not $SuccessBool) { "tool_execution_failure" } else { "none" }
    $SafeMistakeType = "$MistakeType" -replace "'", "''"

    # If tool failed, log as mistake
    if (-not $SuccessBool) {
        # Use execution_id=1 as placeholder, agent_id=1 (general-purpose agent)
        $SafeDescription = "Tool $SafeToolName failed during execution"
        $SafeContext = "Tool: $SafeToolName"

        $Query = @"
INSERT INTO agent_mistakes (
    execution_id, agent_id, mistake_type, mistake_category,
    description, context_when_occurred, identified_at
) VALUES (
    1, 1, '$SafeMistakeType', 'execution',
    '$SafeDescription', '$SafeContext', '$SafeTimestamp'
);
"@
        $ErrorLog = Join-Path "$LogPath" "hook-errors-$(Get-Date -Format 'yyyy-MM-dd').log"
        sqlite3 "$DatabasePath" "$Query" 2>> "$ErrorLog"
    }

    # Update execution log with completion
    $UpdateQuery = @"
UPDATE agent_executions
SET executed_at = '$SafeTimestamp',
    status = '$(if ($SuccessBool) { "success" } else { "failure" })'
WHERE agent_id = 1
  AND executed_at IS NULL
ORDER BY executed_at DESC
LIMIT 1;
"@
    sqlite3 "$DatabasePath" "$UpdateQuery" 2>> "$ErrorLog"

} catch {
    # Log error for debugging
    $ErrorMsg = "[$Timestamp] [POST-TOOL] ERROR: $_"
    Add-Content -Path "$LogFile" -Value "$ErrorMsg" -ErrorAction SilentlyContinue
}

# Exit successfully
exit 0
